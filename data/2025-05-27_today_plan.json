[
  "4. **실습 및 적용 (약 1시간 30분)**",
  "다음은 주어진 내용을 한국어로 요약한 것입니다.\n\n1. **전체적인 개념:**\n   - 주어진 내용은 그래프에서 두 정점 사이의 최단 경로를 찾는 방법, 특히 ‘모든 정점 쌍 간 최단 경로’ (All-pairs shortest path)를 계산하는 방법을 설명합니다.\n   - 그래프의 정점은 1부터 n까지로 표현하며, k-distance matrix D(k)를 사용하여 k개의 정점을 중간 경로로 사용할 수 있는 경우의 최단 경로 길이를 계산합니다.\n   - D(0)은 정점 i와 j 사이의 직접적인 거리(경로가 하나인 경우)를 나타냅니다.\n   - D(n)은 최종적으로 원하는 정보, 즉 모든 정점 쌍 간의 최단 거리를 담고 있습니다.\n\n2. **최적성 재귀 구조 (Recursive Structure of Optimality):**\n   - 그래프의 정점은 1부터 n까지 사용합니다.\n   - Proposition 17에 따르면, v1v2…vm…vl이 최단 경로일 경우, v1…vm과 vm…vl 또한 최단 경로입니다.  또한, 1부터 k개의 정점을 중간 경로로 사용하는 경로에도 동일한 원칙이 적용됩니다.\n   - 즉, 최단 경로를 구성하는 부분 경로 또한 최단 경로가 됩니다.\n\n3. **증명 (Proof):**\n   - 만약 v1v2…vm→1vm이 최단 경로가 아니라고 가정하고, v1v↑2…v↑m→1vm보다 짧은 경로가 존재한다고 가정하면, v1v2…vm→1vm보다 더 짧은 경로, 즉 v1v↑2…v↑m→1vm…vl이 존재해야 합니다. 이는 v1v2…vm→1vm이 최단 경로라는 가정에 모순됩니다. 따라서 v1v2…vm→1vm은 최단 경로입니다.\n   - 이와 동일한 논리는 vm…vl의 최단 경로에 대해서도 적용됩니다.\n   - 1부터 k개의 정점을 중간 경로로 사용하는 경로에 대해서도 동일한 방식으로 증명할 수 있습니다.\n\n4. **반복적인 계산 (Recursive Equation):**\n   - Proposition 18에 따르면, D(k)i,j는 다음과 같이 계산됩니다.\n     D(k)i,j = min{ D(k→1)i,j,  D(k→1)i,k + D(k→1)k,j }\n   - 이는 k=1부터 k=n까지 반복적으로 계산하여 D(n)을 구하는 방식입니다. 즉, D(k→1)를 사용하여 D(k)를 계산하고, 이를 통해 D(n)을 점진적으로 구하는 동적 계획법(dynamic programming) 알고리즘을 사용합니다.\n"
]