6.7.1
Implemetations of Prim’s Algorithm
The following is a straightforward implementation of Prim’s algorithm.
Input: Connected undirected weighted graph G as adjacency list
Output: the edges of a minimum spanning tree of G
Init:
X <- {s}
// s is an arbitrarily chosen vertex.
T <- {}
// chosen edges; initially empty.
Main loop:
for n-1 iterations
Among edges (u,v) with u in X and v not in X
Take (u*,v*) with minimum weight
Add v* into X
Add (u*,v*) into T
return T
What is the running time of this implementation? Answer: O(nm). At each iteration, we
need to do the validity check for all the edges, that is whether, for (u, v), u →X and v ↑→X.
Improvement using heap-based priority queue
We can improve using a heap-based
priority queue. Together with the usual pop() and push(), we use update key operation that
runs, again, in O(log n) time. [[ Revise the code in the style of Dijkstra!!! ]]
1
Init:
2
X <- {s}; T <- {}
3
Q: priority queue (of vertices with keys)
4
5
for each v != s
6
if there is edge (s,v)
7
key(v) <- w(s,v);
e(v) <- (s,v)
8
else
9
key(v) <- infty;
e(v) <- NULL
10
push(v)
11
12
Main loop:
13
while Q is non-empty
14
v* <- pop()
// the closest vertex chosen.
15
Add v* into X
16
Add e(v*) into T
17
// update keys
18
for each edge (v*,y) with y not in X
// we’re using adj list!
19
if w(v*,y) < key(y)
20
update key(y) <- w(v*,y); e(y) <- (v*,y)
21
return T
107
"
우선큐
"
개번.
The loop in the initialization (lines 5–10) performs n heap operations. Therefore, it takes
O(n log n) time. The main loop has n ↓1 iterations, in which we have a heap operation and
constant-time operations (lines 14–16) and a for loop (lines 18–20). Except for the for loop, it
takes O(n log n) time. Now, the inner for loop itself is hard to estimate, but during the overall
lifetime of the main loop, O(m) edges are checked for key updates, and so, it takes O(m log n).
Therefore, in total, the running time is O((n + m) log n).
6.7.2
Implementation of Kruskal’s algorithm
While Prim’s algorithm grows a single tree that eventually becomes the minimum spanning
tree, Kruskal’s algorithm maintains a subgraph that can have more than one component, which
grows to become a minimum spanning tree. For example, see the following illustration:
Figure 13: An illustration of Kruskal’s algorithm.
Edges are added in the order of weights, and note that the edge of weight 6 could not be
added because it makes a cycle. Now, let us see the following straightforward implementation
of Kruskal’s algorithm:
Input: Connected undirected weighted graph G as adjacency list
Output: the edges of a minimum spanning tree of G
Preprocessing:
S <- {}
// chosen edges; initially empty. S for subgraph :)
Sort edges by weights
Main loop:
for each edge e, in increasing order of weight
if S and e does not make a cycle
108
꼭집점6개
d
edge
y개
ㅇ
↳이거해도우선은cycle안생니까.
-
따라서정렬
개→
O nlogn)
